/*
*
* !Code generated by knitr.  Do Not Edit!
*
* Calculates empirical power for a mixed model design
* 
* Design Name: `r design@name`
*
* Design Description:
* `r design@description`
*/

%include "common.sas";

* define the mixed model fitting macro for 2 group 5 repeated measures design; 
%macro longit2Group5Rm(datasetName);
  proc mixed data=&datasetName;
		model y = trt1_rep1 trt1_rep2 trt1_rep3 trt1_rep4 trt1_rep5
				trt2_rep1 trt2_rep2 trt2_rep3 trt2_rep4 trt2_rep5 / noint solution ddfm=kr;
		repeated / subject=subjectID type=`r covName`;
		by setID;
		contrast "time by treatment"
			trt1_rep1 1 trt1_rep2 -1 trt2_rep1 -1 trt2_rep2 1,
			trt1_rep1 1 trt1_rep3 -1 trt2_rep1 -1 trt2_rep3 1,
			trt1_rep1 1 trt1_rep4 -1 trt2_rep1 -1 trt2_rep4 1,
			trt1_rep1 1 trt1_rep5 -1 trt2_rep1 -1 trt2_rep5 1;
	run;
%mend;

ods graphics off;
/*
* Calculate empirical power for 2 group, longitudinal trials
*/
proc iml;

  replicates = `r sim.replicates`;
  setSize = `r sim.setSize`;
  simlibname = `r sim.libname`;
  simPrefix = `r sim.libname`;

  /* function to generate data for given ISU */
  start genDataForPattern(startId, size, X, Beta, mu, Sigma, output);
    do id = startId to startId + size;
      E = randnormal(1, mu, Sigma);
      Y = X * Beta + E`;
      output = output // (J(ncol(Sigma),1,id));
    end;
  finish; /* genDataForPattern */

  datasetPrefix = simlibname + "." + simprefix;

	* determine the number of sets;
	numSets = replicates / setSize;

	FullColNames = {"setID" "Y" "E"} || `r Xnames`;

	/*
	*
	* We create a total of #replicates data sets in the
	* long format appropriate for PROC MIXED.
	*
	* The replicates are split across multiple files of size 'setSize'
	* with the start and end replicate number in the filename.
	*
	* Each data contains the following fields
	*  setID - the data set identifier
	*  Y - the simulated Y values
	*  E - the simulated errors
	*  X - all columns from the user specified X matrix with
	*    column names as specified in XFullColNames
	*/
	do setNum = 1 to numSets;
	  do repNum = 1 to setSize;

	  	free X;
			free E;
			free Y;

      /* generate the data for each ISU */
```{r echo=FALSE}
  # output SAS/IML matrix code for a given matrix
  catSASMatrix <- function(name, m) {
    cat(name, " = {\n")
    for(r in 1:nrow(m)) {
      for(c in 1:ncol(m)) {
        cat(m[r,c], " ")
      }
      if(r == nrow(m)) {
        cat("\n")
      } else {
        cat(",\n")
      }
    }
    cat("};\n")
  }

  # output SAS code for data generation for each pattern
  cat("      startId=1;")
  for(pattern in design@missingDataPattern) {
    # get sigma matrix for this pattern
    deletionMatrix = matrix(diag(maxObs)[pattern@observations,], 
                            nrow=length(pattern@observations))
    Sigma = (deletionMatrix %*% design@Sigma %*% t(deletionMatrix))
    # create mu
    mu = matrix(rep(0, length(pattern@observations)), ncol=1)

    # output code for data generation
    cat("      genDataForPattern(startId, size, X, Beta, mu, Sigma, output);")
    cat("      startId = startId + size;")
  }
```
			* build the data set;
			block = (J(NROW(Y),1,repNum + ((setNum-1)*setSize)) || Y || E || X);
			mattrib block colname=(FullColNames); 

			* append the full X matrix to the data set;
			output = output // block;
		  end;
		  * write to disk;
		  startIterNum = (setNum-1)*setSize+1;
		  startIter = char(startIterNum);
		  endIterNum = startIterNum + setSize - 1;
		  endIter = char(endIterNum); 
		  dataSetName = datasetPrefix + "Iter" + strip(startIter) + 
				"to" + strip(endIter);

		  dsList = dsList // dataSetname;

		  /*
		  * Write a temporary data set since I
		  * can't convince IML to use a dynamic name here
		  */
		  create temp from output[colname=FullColNames];
		  append from output;
		  close temp;
		  free output;

		  /*
		  * Change the name of the data set using SAS
		  */
		  submit dataSetName;
			data &dataSetName;
				set temp;
			run;
		  endsubmit;
		  
		  * remove the temp data set;
		  call delete("work", "temp"); 
		end;
  end;

  /*** now calculate empirical power ***/


	* build the name of the contrast data set;
	contrastDataSet = "contrasts" + "_" + simprefix; 
	empiricalPowerDataSet = "empiricalPower" + "_" + simprefix; 

	* cleanup the SAS environment before we start;
	submit contrastDataSet;
		proc datasets;
			delete &contrastDataSet;
		run;
	endsubmit;

  do i = 1 to nrow(dsList);
	  * get the data set name;
		sdCurrent = dsList[i];
		print sdCurrent;
		* call proc mixed;
		submit sdCurrent macroName contrastDataSet;
		ods exclude all;
		ods noresults;
		* fit the model and output p-value for test;
		ods output Contrasts=tmpSimContrasts;
		  %&macroName(&sdCurrent);
		* append the results to the running data set;
		proc append base = &contrastDataSet data = tmpSimContrasts force; run;
			ods results;
			ods exclude none;
		endsubmit;
	end;

	* put the SAS environment back the way we found it;
	submit contrastDataSet empiricalPowerDataSet;
		data &contrastDataSet;
		  set &contrastDataSet;
		  reject = (probf < 0.05);
	    run;
		proc freq data=&contrastDataSet;
			tables reject / out=&empiricalPowerDataSet;
		run;
		* stupid BS since the dynamic name only works on 64bit SAS;
		data temp;
			set &empiricalPowerDataSet;
			where reject = 1;
			keep percent;
		run;
  endsubmit;

	use temp;
		read all into empiricalPower;
	close temp;

	* remove the temp data set;
	call delete("work", "temp"); 

	* convert to a decimal from a percent;
	empiricalPower = empiricalPower / 100;

	finish;
	
	* create result set;
	resultNames = paramNames || "empiricalPower";
	results = paramList || empiricalPowerResults;
	print results;
	print resultNames;
	* write power results to a data set;
	create clusterRandomizedEmpirical from 
		results[colname=resultNames];
	append from results;
	close clusterRandomizedEmpirical;
quit;

* write the temporary empirical power data set to disk as a csv;
proc export data=clusterRandomizedEmpirical
   outfile="&OUT_DATA_DIR\clusterLargeEmpirical.csv"
   dbms=csv
   replace;
run;



















##############################
%include "common.sas";

* define the mixed model fitting macro; 
* this must contain a 'by setID' statement, but can otherwise;
* be defined as needed by the model;
%macro fitMixedModelShort(datasetName);
  proc mixed data=&datasetName;
		model y = A B / noint solution ddfm=KR;
		random int / subject=clusterID;
		by setID;
		contrast "trt" A 1 B -1;
	run;
%mend;

/*
* Generate the data sets
*/
proc iml;
	%INCLUDE "&MODULES_DIR\simulateMixedModel.sxs"/NOSOURCE2;


```
Xessence = {
	1 0 ,
	0 1
};

X = Xessence@J(35,1,1);
ISU = J(5,1,1) // J(10,1,2) // J(10,1,3) // J(5,1,4) // J(5,1,5) //
		J(5,1,6) // J(10,1,7) // J(10,1,8) // J(5,1,9) // J(5,1,10);

X = ISU || X ;
XFullColNames={"clusterId" "A" "B"}; 
XModelColNames = {"A" "B" };
mattrib X colname=XFullColNames; 
Xmodel = X[,XModelColNames];

print X;
Beta = {1,0};

SigmaSmall = 2#(J(5,5,1)*0.3+I(5)*0.7);
SigmaBig = 2#(J(10,10,1)*0.3+I(10)*0.7);
SigmaS = block(SigmaSmall,SigmaBig,SigmaBig,SigmaSmall,SigmaSmall,
				SigmaSmall,SigmaBig,SigmaBig,SigmaSmall,SigmaSmall);
print SigmaS;
C = {1 -1};
thetaNull = {0};
alpha = {0.05};
simlib= "outData";
simprefix = "simCaseStudy05";

call calculateEmpiricalPowerConditional(10000, 1000,  
  simlib, simprefix, "fitMixedModelShort",
  X, XFullColNames, XModelColNames, Beta, SigmaS,
  powerResults);

* now call the approximation;
power = calculatePowerKenwardRoger(Xmodel, Beta, C, SigmaS, thetaNull, alpha, 10);
print power;
print powerResults;
quit;
